-- -------------------------------------------------------------
-- 
-- File Name: hdl_prj\hdlsrc\ZynqBF_2tx_fpga\ZynqBF_2t_ip_src_rx_q_fifo.vhd
-- Created: 2019-02-08 23:33:52
-- 
-- Generated by MATLAB 9.5 and HDL Coder 3.13
-- 
-- -------------------------------------------------------------


-- -------------------------------------------------------------
-- 
-- Module: ZynqBF_2t_ip_src_rx_q_fifo
-- Source Path: ZynqBF_2tx_fpga/channel_estimator/in_fifo/rx_q_fifo
-- Hierarchy Level: 3
-- 
-- 
-- -------------------------------------------------------------
LIBRARY IEEE;
USE IEEE.std_logic_1164.ALL;
USE IEEE.numeric_std.ALL;

ENTITY ZynqBF_2t_ip_src_rx_q_fifo IS
  PORT( clk                               :   IN    std_logic;
        reset                             :   IN    std_logic;
        enb                               :   IN    std_logic;
        enb_1_128_1                       :   IN    std_logic;
        enb_1_1_1                         :   IN    std_logic;
        In_rsvd                           :   IN    std_logic_vector(15 DOWNTO 0);  -- sfix16_En15
        Push                              :   IN    std_logic;
        Pop                               :   IN    std_logic;
        Out_rsvd                          :   OUT   std_logic_vector(15 DOWNTO 0);  -- sfix16_En15
        Empty                             :   OUT   std_logic  -- ufix1
        );
END ZynqBF_2t_ip_src_rx_q_fifo;


ARCHITECTURE rtl OF ZynqBF_2t_ip_src_rx_q_fifo IS

  -- Component Declarations
  COMPONENT ZynqBF_2t_ip_src_SimpleDualPortRAM_generic
    GENERIC( AddrWidth                    : integer;
             DataWidth                    : integer
             );
    PORT( clk                             :   IN    std_logic;
          ram_rst                         :   IN    std_logic;
          enb                             :   IN    std_logic;
          wr_din                          :   IN    std_logic_vector(DataWidth - 1 DOWNTO 0);  -- generic width
          wr_addr                         :   IN    std_logic_vector(AddrWidth - 1 DOWNTO 0);  -- generic width
          wr_en                           :   IN    std_logic;  -- ufix1
          rd_addr                         :   IN    std_logic_vector(AddrWidth - 1 DOWNTO 0);  -- generic width
          rd_dout                         :   OUT   std_logic_vector(DataWidth - 1 DOWNTO 0)  -- generic width
          );
  END COMPONENT;

  -- Component Configuration Statements
  FOR ALL : ZynqBF_2t_ip_src_SimpleDualPortRAM_generic
    USE ENTITY work.ZynqBF_2t_ip_src_SimpleDualPortRAM_generic(rtl);

  -- Signals
  SIGNAL us2_zero                         : std_logic;
  SIGNAL us2_muxout                       : std_logic;
  SIGNAL us2_bypass_reg                   : std_logic;  -- ufix1
  SIGNAL us2_bypassout                    : std_logic;
  SIGNAL fifo_front_indx                  : unsigned(13 DOWNTO 0);  -- ufix14
  SIGNAL fifo_front_dir                   : unsigned(13 DOWNTO 0);  -- ufix14
  SIGNAL fifo_back_indx                   : unsigned(13 DOWNTO 0);  -- ufix14
  SIGNAL fifo_back_dir                    : unsigned(13 DOWNTO 0);  -- ufix14
  SIGNAL fifo_sample_count                : unsigned(13 DOWNTO 0);  -- ufix14
  SIGNAL fifo_front_indx_next             : unsigned(13 DOWNTO 0);  -- ufix14
  SIGNAL fifo_front_dir_next              : unsigned(13 DOWNTO 0);  -- ufix14
  SIGNAL fifo_back_indx_next              : unsigned(13 DOWNTO 0);  -- ufix14
  SIGNAL fifo_back_dir_next               : unsigned(13 DOWNTO 0);  -- ufix14
  SIGNAL fifo_sample_count_next           : unsigned(13 DOWNTO 0);  -- ufix14
  SIGNAL fifo_out3                        : std_logic;
  SIGNAL fifo_out4                        : std_logic;
  SIGNAL fifo_write_enable                : std_logic;
  SIGNAL fifo_read_enable                 : std_logic;
  SIGNAL fifo_front_indx_temp             : unsigned(13 DOWNTO 0);  -- ufix14
  SIGNAL fifo_back_indx_temp              : unsigned(13 DOWNTO 0);  -- ufix14
  SIGNAL w_waddr                          : unsigned(13 DOWNTO 0);  -- ufix14
  SIGNAL w_we                             : std_logic;  -- ufix1
  SIGNAL w_raddr                          : unsigned(13 DOWNTO 0);  -- ufix14
  SIGNAL w_full                           : std_logic;  -- ufix1
  SIGNAL w_num                            : unsigned(13 DOWNTO 0);  -- ufix14
  SIGNAL w_cz                             : std_logic;
  SIGNAL w_mux1                           : std_logic;  -- ufix1
  SIGNAL w_d1                             : std_logic;  -- ufix1
  SIGNAL In_signed                        : signed(15 DOWNTO 0);  -- sfix16_En15
  SIGNAL us1_zero                         : signed(15 DOWNTO 0);  -- sfix16_En15
  SIGNAL us1_muxout                       : signed(15 DOWNTO 0);  -- sfix16_En15
  SIGNAL us1_bypass_reg                   : signed(15 DOWNTO 0);  -- sfix16
  SIGNAL us1_bypassout                    : signed(15 DOWNTO 0);  -- sfix16_En15
  SIGNAL w_waddr_1                        : std_logic_vector(15 DOWNTO 0);  -- ufix16
  SIGNAL w_waddr_signed                   : signed(15 DOWNTO 0);  -- sfix16_En15
  SIGNAL w_d2                             : signed(15 DOWNTO 0);  -- sfix16_En15
  SIGNAL w_out                            : signed(15 DOWNTO 0);  -- sfix16_En15

BEGIN
  u_rx_q_fifo_ram : ZynqBF_2t_ip_src_SimpleDualPortRAM_generic
    GENERIC MAP( AddrWidth => 14,
                 DataWidth => 16
                 )
    PORT MAP( clk => clk,
              ram_rst => '0',
              enb => enb,
              wr_din => std_logic_vector(us1_bypassout),
              wr_addr => std_logic_vector(w_waddr),
              wr_en => w_we,  -- ufix1
              rd_addr => std_logic_vector(w_raddr),
              rd_dout => w_waddr_1
              );

  -- us2: Upsample by 128, Sample offset 0 
  us2_zero <= '0';

  
  us2_muxout <= Push WHEN enb_1_128_1 = '1' ELSE
      us2_zero;

  -- Upsample bypass register
  us2_bypass_process : PROCESS (clk)
  BEGIN
    IF clk'EVENT AND clk = '1' THEN
      IF reset = '1' THEN
        us2_bypass_reg <= '0';
      ELSIF enb_1_1_1 = '1' THEN
        us2_bypass_reg <= us2_muxout;
      END IF;
    END IF;
  END PROCESS us2_bypass_process;

  
  us2_bypassout <= us2_muxout WHEN enb_1_1_1 = '1' ELSE
      us2_bypass_reg;

  -- FIFO logic controller
  fifo_process : PROCESS (clk)
  BEGIN
    IF clk'EVENT AND clk = '1' THEN
      IF reset = '1' THEN
        fifo_front_indx <= to_unsigned(16#0000#, 14);
        fifo_front_dir <= to_unsigned(16#0001#, 14);
        fifo_back_indx <= to_unsigned(16#0000#, 14);
        fifo_back_dir <= to_unsigned(16#0001#, 14);
        fifo_sample_count <= to_unsigned(16#0000#, 14);
      ELSIF enb = '1' THEN
        fifo_front_indx <= fifo_front_indx_next;
        fifo_front_dir <= fifo_front_dir_next;
        fifo_back_indx <= fifo_back_indx_next;
        fifo_back_dir <= fifo_back_dir_next;
        fifo_sample_count <= fifo_sample_count_next;
      END IF;
    END IF;
  END PROCESS fifo_process;

  
  fifo_out4 <= '1' WHEN fifo_sample_count = to_unsigned(16#22D0#, 14) ELSE
      '0';
  
  fifo_out3 <= '1' WHEN fifo_sample_count = to_unsigned(16#0000#, 14) ELSE
      '0';
  fifo_write_enable <= us2_bypassout AND (Pop OR ( NOT fifo_out4));
  fifo_read_enable <= Pop AND ( NOT fifo_out3);
  
  fifo_front_indx_temp <= fifo_front_indx + fifo_front_dir WHEN fifo_read_enable = '1' ELSE
      fifo_front_indx;
  
  fifo_front_dir_next <= to_unsigned(16#1D31#, 14) WHEN fifo_front_indx_temp = to_unsigned(16#22CF#, 14) ELSE
      to_unsigned(16#0001#, 14);
  
  fifo_back_indx_temp <= fifo_back_indx + fifo_back_dir WHEN fifo_write_enable = '1' ELSE
      fifo_back_indx;
  
  fifo_back_dir_next <= to_unsigned(16#1D31#, 14) WHEN fifo_back_indx_temp = to_unsigned(16#22CF#, 14) ELSE
      to_unsigned(16#0001#, 14);
  
  fifo_sample_count_next <= fifo_sample_count + to_unsigned(16#0001#, 14) WHEN (fifo_write_enable AND ( NOT fifo_read_enable)) = '1' ELSE
      fifo_sample_count + to_unsigned(16#3FFF#, 14) WHEN (( NOT fifo_write_enable) AND fifo_read_enable) = '1' ELSE
      fifo_sample_count;
  w_waddr <= fifo_back_indx;
  w_we <= fifo_write_enable;
  w_raddr <= fifo_front_indx;
  Empty <= fifo_out3;
  w_full <= fifo_out4;
  w_num <= fifo_sample_count;
  fifo_front_indx_next <= fifo_front_indx_temp;
  fifo_back_indx_next <= fifo_back_indx_temp;

  
  w_cz <= '1' WHEN w_num > to_unsigned(16#0000#, 14) ELSE
      '0';

  
  w_mux1 <= '0' WHEN w_cz = '0' ELSE
      Pop;

  f_d1_process : PROCESS (clk)
  BEGIN
    IF clk'EVENT AND clk = '1' THEN
      IF reset = '1' THEN
        w_d1 <= '0';
      ELSIF enb = '1' THEN
        w_d1 <= w_mux1;
      END IF;
    END IF;
  END PROCESS f_d1_process;


  -- us3: Upsample by 1, Sample offset 0 
  In_signed <= signed(In_rsvd);

  -- us1: Upsample by 128, Sample offset 0 
  us1_zero <= to_signed(16#0000#, 16);

  
  us1_muxout <= In_signed WHEN enb_1_128_1 = '1' ELSE
      us1_zero;

  -- Upsample bypass register
  us1_bypass_process : PROCESS (clk)
  BEGIN
    IF clk'EVENT AND clk = '1' THEN
      IF reset = '1' THEN
        us1_bypass_reg <= to_signed(16#0000#, 16);
      ELSIF enb_1_1_1 = '1' THEN
        us1_bypass_reg <= us1_muxout;
      END IF;
    END IF;
  END PROCESS us1_bypass_process;

  
  us1_bypassout <= us1_muxout WHEN enb_1_1_1 = '1' ELSE
      us1_bypass_reg;

  w_waddr_signed <= signed(w_waddr_1);

  f_d2_process : PROCESS (clk)
  BEGIN
    IF clk'EVENT AND clk = '1' THEN
      IF reset = '1' THEN
        w_d2 <= to_signed(16#0000#, 16);
      ELSIF enb = '1' AND w_d1 = '1' THEN
        w_d2 <= w_waddr_signed;
      END IF;
    END IF;
  END PROCESS f_d2_process;


  
  w_out <= w_d2 WHEN w_d1 = '0' ELSE
      w_waddr_signed;

  Out_rsvd <= std_logic_vector(w_out);

END rtl;

