-- -------------------------------------------------------------
-- 
-- File Name: hdl_prj\hdlsrc\ZynqBF_2tx_fpga\ZynqBF_2t_ip_src_in_fifo.vhd
-- Created: 2019-02-08 23:33:52
-- 
-- Generated by MATLAB 9.5 and HDL Coder 3.13
-- 
-- -------------------------------------------------------------


-- -------------------------------------------------------------
-- 
-- Module: ZynqBF_2t_ip_src_in_fifo
-- Source Path: ZynqBF_2tx_fpga/channel_estimator/in_fifo
-- Hierarchy Level: 2
-- 
-- -------------------------------------------------------------
LIBRARY IEEE;
USE IEEE.std_logic_1164.ALL;
USE IEEE.numeric_std.ALL;

LIBRARY UNISIM;
use UNISIM.vcomponents.all;

LIBRARY UNIMACRO;
use UNIMACRO.vcomponents.all;

ENTITY ZynqBF_2t_ip_src_sync_csi IS
  PORT( clk                             :   IN    std_logic;
        clk200                          :   IN    std_logic;
        reset                           :   IN    std_logic;
        reset200                        :   IN    std_logic;
        enb                             :   IN    std_logic;
        enb200                          :   IN    std_logic;
        ch1i_i                          :   IN    std_logic_vector(15 downto 0);
        ch1q_i                          :   IN    std_logic_vector(15 downto 0);
        ch2i_i                          :   IN    std_logic_vector(15 downto 0);
        ch2q_i                          :   IN    std_logic_vector(15 downto 0);
        ch1i_o                          :   OUT   std_logic_vector(15 downto 0);
        ch1q_o                          :   OUT   std_logic_vector(15 downto 0);
        ch2i_o                          :   OUT   std_logic_vector(15 downto 0);
        ch2q_o                          :   OUT   std_logic_vector(15 downto 0);
        est_done                        :   IN    std_logic
        );
END ZynqBF_2t_ip_src_sync_csi;


ARCHITECTURE rtl OF ZynqBF_2t_ip_src_sync_csi IS

  -- Component Declarations

  -- Signals
  signal ch1i                             : std_logic_vector(15 downto 0);
  signal ch1q                             : std_logic_vector(15 downto 0);
  signal ch2i                             : std_logic_vector(15 downto 0);
  signal ch2q                             : std_logic_vector(15 downto 0);
  
  signal wren                             : std_logic;
  signal rden                             : std_logic;
  signal rden_d1                          : std_logic;
  signal wrdata                           : std_logic_vector(15 downto 0);
  signal rddata                           : std_logic_vector(15 downto 0);
  signal empty_i                          : std_logic;
  
  signal cs_wr                            : std_logic;
  signal cs_rd                            : std_logic;
  constant s_wait                         : std_logic := '0';
  constant s_wr                           : std_logic := '1';
  constant s_rd                           : std_logic := '1';
  
  signal wr_cnt                           : unsigned(1 downto 0);
  signal rd_cnt                           : unsigned(1 downto 0);
  
BEGIN
  
  u_sync_fifo : FIFO_DUALCLOCK_MACRO
  generic map(
    fifo_size => "36Kb",
    data_width => 16,
    almost_full_offset => x"0009",
    almost_empty_offset => x"0009"
    )
  port map(
    rst => reset,
    wrclk => clk200,
    wren => wren,
    di => wrdata,
    full => open,
    rdclk => clk,
    rden => rden,
    do => rddata,
    empty => empty_i,
    almostempty => open,
    almostfull => open,
    wrerr => open,
    rderr => open,
    wrcount => open,
    rdcount => open
  );  
  
  -- Write side signals
  write_fsm : process(clk200)
  begin
    if clk200'event and clk200 = '1' then
      if reset200 = '1' then
        cs_wr <= s_wait;
      elsif enb200 = '1' then
        case cs_wr is
          when s_wait =>
            if est_done = '1' then
              cs_wr <= s_wr;
            else
              cs_wr <= s_wait;
            end if;
          when s_wr =>
            if wr_cnt = "11" then
              cs_wr <= s_wait;
            else
              cs_wr <= s_wr;
            end if;
          when others =>
            cs_wr <= s_wait;
        end case;
      end if;
    end if;
  end process;
  
  wr_cnt_process : process(clk200)
  begin
    if clk200'event and clk200 = '1' then
      if reset200 = '1' then
        wr_cnt <= "00";
      elsif enb200 = '1' and cs_wr = s_wr then
        wr_cnt <= wr_cnt + "01";
      else
        wr_cnt <= "00";
      end if;
    end if;
  end process;
  
  wren <= '1' when enb200 = '1' and cs_wr = s_wr else '0';
  
  with wr_cnt select wrdata <=
    ch1i_i when "00",
    ch1q_i when "01",
    ch2i_i when "10",
    ch2q_i when "11",
    x"0000" when others;
  
  
  -- Read side signals
  read_fsm : process(clk)
  begin
    if clk'event and clk = '1' then
      if reset = '1' then
        cs_rd <= s_wait;
      elsif enb = '1' then
        case cs_rd is
          when s_wait =>
            if empty_i = '0' then
              cs_rd <= s_rd;
            else
              cs_rd <= s_wait;
            end if;
          when s_rd =>
            if rd_cnt = "11" then
              cs_rd <= s_wait;
            else
              cs_rd <= s_rd;
            end if;
          when others =>
            cs_rd <= s_wait;
        end case;
      end if;
    end if;
  end process;
  
  rd_cnt_process : process(clk)
  begin
    if clk'event and clk = '1' then
      if reset = '1' then
        rd_cnt <= "00";
      elsif enb = '1' and rden_d1 = '1' then
        rd_cnt <= rd_cnt + "01";
      else
        rd_cnt <= "00";
      end if;
    end if;
  end process;
  
  rden <= '1' when enb = '1' and cs_rd = s_rd else '0';
  
  rden_delay_process : process(clk)
  begin
    if clk'event and clk = '1' then
      if reset = '1' then
        rden_d1 <= '0';
      elsif enb = '1' then
        rden_d1 <= rden;
      end if;
    end if;
  end process;
  
  csi_sync_process : process(clk)
  begin
    if clk'event and clk = '1' then
      if reset = '1' then
        ch1i <= x"0000";
        ch1q <= x"0000";
        ch2i <= x"0000";
        ch2q <= x"0000";
      elsif enb = '1' then
        if cs_rd = s_rd then
          case rd_cnt is
            when "00" =>
              ch1i <= rddata;
              ch1q <= ch1q;
              ch2i <= ch2i;
              ch2q <= ch2q;
            when "01" =>
              ch1i <= ch1i;
              ch1q <= rddata;
              ch2i <= ch2i;
              ch2q <= ch2q;
            when "10" =>
              ch1i <= ch1i;
              ch1q <= ch1q;
              ch2i <= rddata;
              ch2q <= ch2q;
            when "11" =>
              ch1i <= ch1i;
              ch1q <= ch1q;
              ch2i <= ch2i;
              ch2q <= rddata;
            when others =>
              ch1i <= ch1i;
              ch1q <= ch1q;
              ch2i <= ch2i;
              ch2q <= ch2q;
          end case;
        end if;
      end if;
    end if;
  end process;
  
  ch1i_o <= ch1i;
  ch1q_o <= ch1q;
  ch2i_o <= ch2i;
  ch2q_o <= ch2q;

END rtl;

