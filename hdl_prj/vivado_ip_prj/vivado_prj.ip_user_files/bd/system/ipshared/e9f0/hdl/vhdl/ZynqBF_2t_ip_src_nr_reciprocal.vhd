-- -------------------------------------------------------------
-- 
-- File Name: hdl_prj\hdlsrc\ZynqBF_2tx_fpga\ZynqBF_2t_ip_src_HDL_Reciprocal.vhd
-- Created: 2019-02-08 23:33:52
-- 
-- Generated by MATLAB 9.5 and HDL Coder 3.13
-- 
-- -------------------------------------------------------------


-- -------------------------------------------------------------
-- 
-- Module: ZynqBF_2t_ip_src_HDL_Reciprocal
-- Source Path: ZynqBF_2tx_fpga/channel_estimator/ch_est/calc_inverse/HDL Reciprocal
-- Hierarchy Level: 4
-- 
-- -------------------------------------------------------------
LIBRARY IEEE;
USE IEEE.std_logic_1164.ALL;
USE IEEE.numeric_std.ALL;
USE work.ZynqBF_2t_ip_src_ZynqBF_2tx_fpga_pkg.ALL;

ENTITY ZynqBF_2t_ip_src_nr_reciprocal IS
  PORT( clk                               :   IN    std_logic;
        reset                             :   IN    std_logic;
        enb                               :   IN    std_logic;
        din                               :   IN    std_logic_vector(31 DOWNTO 0);  -- sfix32_En16
        start                             :   IN    std_logic;
        dout                              :   OUT   std_logic_vector(31 DOWNTO 0);  -- sfix32_En14
        valid                             :   OUT   std_logic
        );
END ZynqBF_2t_ip_src_nr_reciprocal;


ARCHITECTURE rtl OF ZynqBF_2t_ip_src_nr_reciprocal IS

  -- Signals
  signal cs_nr                            : std_logic_vector(3 downto 0);
  constant s_idle                         : std_logic_vector(3 downto 0) := "0001";
  constant s_init                         : std_logic_vector(3 downto 0) := "0010";
  constant s_calc                         : std_logic_vector(3 downto 0) := "0100";
  constant s_done                         : std_logic_vector(3 downto 0) := "1000";
  
  signal iteration_cnt                    : unsigned(3 downto 0);
  constant n_iterations                   : unsigned(3 downto 0) := to_unsigned(10, 4);
  
  signal din_i                            : std_logic_vector(31 downto 0);
  signal dout_i                           : std_logic_vector(31 downto 0);
  signal a                                : signed(31 downto 0);
  signal x                                : signed(31 downto 0);
  
  signal step                             : std_logic;
  signal step_cnt                         : unsigned(3 downto 0);
  signal n_steps                          : unsigned(3 downto 0) := to_unsigned(4,4);
  
  constant const2                         : signed(63 downto 0) := x"0000000200000000";  -- constant 2 for nr equation xn = x*(2 - a*x)
  
  -- multiplier signals
  signal min1                             : signed(31 downto 0);
  signal min2                             : signed(31 downto 0);
  signal mout                             : signed(63 downto 0);

BEGIN

din_i <= '0' & din(30 downto 0);

cs_nr_process: process(clk)
begin
    if clk'event and clk = '1' then
        if reset = '1' then
            cs_nr <= s_idle;
        else
            case cs_nr is
                when s_idle =>
                    if start = '1' then
                        cs_nr <= s_init;
                    else
                        cs_nr <= s_idle;
                    end if;
                when s_init =>
                    cs_nr <= s_calc;
                when s_calc =>
                    if iteration_cnt > n_iterations then
                        cs_nr <= s_done;
                    else
                        cs_nr <= s_calc;
                    end if;
                when s_done =>
                    cs_nr <= s_idle;
                when others =>
                    cs_nr <= s_idle;
            end case;
        end if;
    end if;
end process;

iteration_cnt_process: process(clk)
begin
    if clk'event and clk = '1' then
        if reset = '1' then
            iteration_cnt <= to_unsigned(0, 4);
        elsif cs_nr = s_calc then
            if step = '1' then
                iteration_cnt <= iteration_cnt + to_unsigned(1, 4);
            else
                iteration_cnt <= iteration_cnt;
            end if;
        else
            iteration_cnt <= to_unsigned(0, 4);
        end if;
    end if;
end process;

nr_iterator_process: process(clk)
    variable k:     integer range 0 to 31;
begin
    if clk'event and clk = '1' then
        if reset = '1' then
            a <= to_signed(0, 32);
            x <= to_signed(0, 32);
        elsif cs_nr = s_idle then
            a <= to_signed(0, 32);
            x <= to_signed(0, 32);
        elsif cs_nr = s_init then
            for i in 0 to 30 loop
                if din_i(i) = '1' then
                    k := 31-i;
                end if;
            end loop;
            x(k) <= '1';
            a <= signed(din_i);
        elsif cs_nr = s_calc and step = '1' then
            x <= mout(47 downto 16);
        else
            x <= x;
        end if;
    end if;
end process;

nr_step_cnt_process: process(clk)
begin
    if clk'event and clk = '1' then
        if reset = '1' then
            step_cnt <= to_unsigned(0,4);
        elsif cs_nr = s_calc then
            if step_cnt = n_steps then
                step_cnt <= to_unsigned(0,4);
            else
                step_cnt <= step_cnt + to_unsigned(1,4);
            end if;
        else
            step_cnt <= to_unsigned(0,4);
        end if;
    end if;
end process;

step <= '1' when step_cnt = n_steps else '0';


nr_multiplier_in_process: process(clk)
begin
  if clk'event and clk = '1' then
    if reset = '1' then
      min1 <= to_signed(0, 32);
      min2 <= to_signed(0 ,32);
    elsif cs_nr = s_calc then
      min2 <= x;
      case step_cnt is
        when x"0" =>
          min1 <= a;    -- step 1 is a*x
        when x"2" =>
          min1 <= const2(47 downto 16) - mout(47 downto 16);  -- step 2 is x*(2 - a*x)
        when others =>
          min1 <= min1;
      end case;
    else
      min1 <= to_signed(0, 32);
      min2 <= to_signed(0, 32);
    end if;
  end if;
end process;

nr_multiplier_out_process: process(clk)
begin
  if clk'event and clk = '1' then
    if reset = '1' then
      mout <= to_signed(0, 64);
    elsif cs_nr = s_calc then
      mout <= min1*min2;
    else
      mout <= to_signed(0, 64);
    end if;
  end if;
end process;

dout_process: process(clk)
begin
    if clk'event and clk = '1' then
        if reset = '1' then
            dout_i <= x"00000000";
            valid <= '0';
        elsif cs_nr = s_done then
            dout_i <= std_logic_vector(x);
            valid <= '1';
        else
            dout_i <= dout_i;
            valid <= '0';
        end if;
    end if;
end process;

dout <= dout_i;

END rtl;

