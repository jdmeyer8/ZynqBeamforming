-- -------------------------------------------------------------
-- 
-- File Name: hdl_prj\hdlsrc\ZynqBF_2tx_fpga\ZynqBF_2t_ip_src_rx_bram.vhd
-- Created: 2019-02-08 23:33:52
-- 
-- Generated by MATLAB 9.5 and HDL Coder 3.13
-- 
-- -------------------------------------------------------------


-- -------------------------------------------------------------
-- 
-- Module: ZynqBF_2t_ip_src_rx_bram
-- Source Path: ZynqBF_2tx_fpga/channel_estimator/rx_bram
-- Hierarchy Level: 2
-- 
-- -------------------------------------------------------------
LIBRARY IEEE;
USE IEEE.std_logic_1164.ALL;
USE IEEE.numeric_std.ALL;
USE work.ZynqBF_2t_ip_src_ZynqBF_2tx_fpga_pkg.ALL;

ENTITY ZynqBF_2t_ip_src_rx_bram IS
  PORT( clk                               :   IN    std_logic;
        reset                             :   IN    std_logic;
        enb                               :   IN    std_logic;
        din_i                             :   IN    std_logic_vector(15 DOWNTO 0);  -- sfix16_En15
        din_q                             :   IN    std_logic_vector(15 DOWNTO 0);  -- sfix16_En15
        we                                :   IN    std_logic;
        wr_addr                           :   IN    std_logic_vector(14 downto 0);
        rd_addr                           :   IN    std_logic_vector(14 DOWNTO 0);  -- ufix15
        shift                             :   IN    std_logic_vector(5 downto 0);
        dout_i_single                     :   OUT   std_logic_vector(15 downto 0);
        dout_q_single                     :   OUT   std_logic_vector(15 downto 0);
        dout_i                            :   OUT   vector_of_std_logic_vector16(0 TO 63);  -- rx i data for the correlators
        dout_q                            :   OUT   vector_of_std_logic_vector16(0 TO 63)   -- rx q data for the correlators
        );
END ZynqBF_2t_ip_src_rx_bram;


ARCHITECTURE rtl OF ZynqBF_2t_ip_src_rx_bram IS

  -- Component Declarations
  COMPONENT rx_ram_core
    PORT (
      clka : IN STD_LOGIC;
      wea : IN STD_LOGIC_VECTOR(0 DOWNTO 0);
      addra : IN STD_LOGIC_VECTOR(13 DOWNTO 0);
      dina : IN STD_LOGIC_VECTOR(15 DOWNTO 0);
      douta : OUT STD_LOGIC_VECTOR(511 DOWNTO 0);
      clkb : IN STD_LOGIC;
      enb : IN STD_LOGIC;
      web : IN STD_LOGIC_VECTOR(0 DOWNTO 0);
      addrb : IN STD_LOGIC_VECTOR(13 DOWNTO 0);
      dinb : IN STD_LOGIC_VECTOR(15 DOWNTO 0);
      doutb : OUT STD_LOGIC_VECTOR(511 DOWNTO 0)
    );
  END COMPONENT;

  -- Signals
  
  signal we_d1                              : std_logic;
  signal we1, we2                           : std_logic_vector(0 downto 0);       -- to comply with Xilinx IP core RAM
  signal wr_addr_cnt                        : unsigned(14 DOWNTO 0);              -- wr address counter that counts up to 32,768
  signal wr_addr_i                          : std_logic_vector(13 DOWNTO 0);      -- wr address for each of the 2 RAMs - RAM1 is written to when bit 6 is 0, RAM2 is written to when bit 6 is 1
  signal rd_addr_i                          : std_logic_vector(13 DOWNTO 0);      -- rd address for each of the 2 RAMs - RAM1 is read from when bit 6 is 0, RAM2 is read from when bit 6 is 1
  signal douta_i1, doutb_i1                 : std_logic_vector(511 downto 0);
  signal douta_i2, doutb_i2                 : std_logic_vector(511 downto 0);
  signal douta_q1, doutb_q1                 : std_logic_vector(511 downto 0);
  signal douta_q2, doutb_q2                 : std_logic_vector(511 downto 0);
  
  signal dout_i1_single, dout_i2_single     : std_logic_vector(15 downto 0);
  signal dout_q1_single, dout_q2_single     : std_logic_vector(15 downto 0);
  
  signal addra, addrb                       : std_logic_vector(13 downto 0);
  constant sw_bit                           : integer range 0 to 13 := 5;
  
  signal addr_lsb                           : integer range 0 to 63;
  signal shift_i                            : integer range 0 to 63;
  
  signal rd_addr_d1                         : std_logic_vector(14 downto 0);
  signal rd_addr_d2                         : std_logic_vector(14 downto 0);
  signal rd_addr_d3                         : std_logic_vector(14 downto 0);

BEGIN

  dout_i_single <= douta_i2((15+16*addr_lsb) downto (16*addr_lsb)) when rd_addr_d3(sw_bit) = '1' else douta_i1((15+16*addr_lsb) downto (16*addr_lsb));
  dout_q_single <= douta_q2((15+16*addr_lsb) downto (16*addr_lsb)) when rd_addr_d3(sw_bit) = '1' else douta_q1((15+16*addr_lsb) downto (16*addr_lsb));
  addr_lsb <= to_integer(unsigned(rd_addr_d3((sw_bit-1) downto 0)));
  shift_i <= to_integer(unsigned(shift));

  we1(0) <= not wr_addr(sw_bit) and we; --we_d1;
  we2(0) <=     wr_addr(sw_bit) and we; --we_d1;
  
  wr_addr_i <= std_logic_vector(wr_addr(14 downto (sw_bit+1))) & std_logic_vector(wr_addr((sw_bit-1) downto 0));
  rd_addr_i <= std_logic_vector(rd_addr(14 downto (sw_bit+1))) & std_logic_vector(rd_addr((sw_bit-1) downto 0));
  
  addra <= wr_addr_i when we = '1' else rd_addr_i;
  -- addrb <= std_logic_vector(unsigned(addra) + to_unsigned(64,addrb'length));
  addrb <= std_logic_vector(unsigned(addra) + to_unsigned(32,addrb'length));
  
  rxi_ram1 : rx_ram_core
  PORT MAP (
    clka => clk,
    wea => std_logic_vector(we1),
    addra => addra,
    dina => din_i,
    douta => douta_i1,
    clkb => clk,
    enb => '1',
    web => "0",
    addrb => addrb,
    dinb => x"0000",
    doutb => doutb_i1
  );
  
  rxi_ram2 : rx_ram_core
  PORT MAP (
    clka => clk,
    wea => std_logic_vector(we2),
    addra => addra,
    dina => din_i,
    douta => douta_i2,
    clkb => clk,
    enb => '1',
    web => "0",
    addrb => addrb,
    dinb => x"0000",
    doutb => doutb_i2
  );
  
  rxq_ram1 : rx_ram_core
  PORT MAP (
    clka => clk,
    wea => std_logic_vector(we1),
    addra => addra,
    dina => din_i,
    douta => douta_q1,
    clkb => clk,
    enb => '1',
    web => "0",
    addrb => addrb,
    dinb => x"0000",
    doutb => doutb_q1
  );
  
  rxq_ram2 : rx_ram_core
  PORT MAP (
    clka => clk,
    wea => std_logic_vector(we2),
    addra => addra,
    dina => din_i,
    douta => douta_q2,
    clkb => clk,
    enb => '1',
    web => "0",
    addrb => addrb,
    dinb => x"0000",
    doutb => doutb_q2
  );

  
  rd_addr_delay_process : process(clk)
  begin
    if clk'event and clk = '1' then
        if reset = '1' then
            rd_addr_d1 <= (others => '0');
            rd_addr_d2 <= (others => '0');
            rd_addr_d3 <= (others => '0');
        elsif enb = '1' then
            rd_addr_d1 <= rd_addr;
            rd_addr_d2 <= rd_addr_d1;
            rd_addr_d3 <= rd_addr_d2;
        end if;
    end if;
  end process;
  
  we_delay_process : process(clk)
  begin
    if clk'event and clk = '1' then
        if reset = '1' then
            we_d1 <= '0';
        elsif enb = '1' then
            we_d1 <= we;
        end if;
    end if;
  end process;
  
  -- outputs to correlator
  register_outputs : process(clk)
  begin
    if clk'event and clk = '1' then
      if reset = '1' then
        --dout_i1_single <= (others => '0');
        --dout_q1_single <= (others => '0');
        --dout_i2_single <= (others => '0');
        --dout_q2_single <= (others => '0');
        dout_i <= (others => (others => '0'));
        dout_q <= (others => (others => '0'));
      elsif enb = '1' then
        --dout_i1_single <= douta_i1((15+16*addr_lsb) downto (16*addr_lsb));
        --dout_q1_single <= douta_q1((15+16*addr_lsb) downto (16*addr_lsb));
        --dout_i2_single <= douta_i2((15+16*addr_lsb) downto (16*addr_lsb));
        --dout_q2_single <= douta_q2((15+16*addr_lsb) downto (16*addr_lsb));
        for i in 0 to 31 loop
          if i < shift_i then
            dout_i(i) <= doutb_i1((15+16*i) downto (16*i));
            dout_q(i) <= doutb_q1((15+16*i) downto (16*i));
          else
            dout_i(i) <= douta_i1((15+16*i) downto (16*i));
            dout_q(i) <= douta_q1((15+16*i) downto (16*i));
          end if;
          if (i+32) < shift_i then
            dout_i(i+32) <= doutb_i2((15+16*i) downto (16*i));
            dout_q(i+32) <= doutb_q2((15+16*i) downto (16*i));
          else
            dout_i(i+32) <= douta_i2((15+16*i) downto (16*i));
            dout_q(i+32) <= douta_q2((15+16*i) downto (16*i));
          end if;
        end loop;
      end if;
    end if;
  end process;
            

END rtl;

