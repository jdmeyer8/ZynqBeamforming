-- -------------------------------------------------------------
-- 
-- File Name: hdl_prj\hdlsrc\ZynqBF_2tx_fpga\ZynqBF_2t_ip_src_rx_bram.vhd
-- Created: 2019-02-08 23:33:52
-- 
-- Generated by MATLAB 9.5 and HDL Coder 3.13
-- 
-- -------------------------------------------------------------


-- -------------------------------------------------------------
-- 
-- Module: ZynqBF_2t_ip_src_rx_bram
-- Source Path: ZynqBF_2tx_fpga/channel_estimator/rx_bram
-- Hierarchy Level: 2
-- 
-- -------------------------------------------------------------
LIBRARY IEEE;
USE IEEE.std_logic_1164.ALL;
USE IEEE.numeric_std.ALL;
USE work.ZynqBF_2t_ip_src_ZynqBF_2tx_fpga_pkg.ALL;

LIBRARY UNISIM;
use UNISIM.vcomponents.all;

LIBRARY UNIMACRO;
use UNIMACRO.vcomponents.all;

ENTITY ZynqBF_2t_ip_src_rx_gs_mult_core IS
  GENERIC( NDSP                           :   integer := 64;    -- number of DSPs to use for multiply-accumulate (real number will be 2x because I and Q)
           SCNT_END                       :   integer := 7      -- sum count end value
        );   
  PORT( clk                               :   IN    std_logic;
        reset                             :   IN    std_logic;
        enb                               :   IN    std_logic;
        mult_en                           :   IN    std_logic;  -- enable for multiplication
        sum_en                            :   IN    std_logic;  -- enable for summation
        scnt                              :   IN    std_logic_vector(15 downto 0);
        rxi                               :   IN    vector_of_std_logic_vector16(0 TO (NDSP-1));  -- rx i data for the multipy-accumulator
        rxq                               :   IN    vector_of_std_logic_vector16(0 TO (NDSP-1));  -- rx q data for the multipy-accumulator
        gsi                               :   IN    vector_of_std_logic_vector16(0 TO (NDSP-1));  -- gs i data for the multipy-accumulator
        gsq                               :   IN    vector_of_std_logic_vector16(0 TO (NDSP-1));  -- gs q data for the multipy-accumulator
        done                              :   OUT   std_logic;
        dout                              :   OUT   std_logic_vector(31 downto 0)
       );
END ZynqBF_2t_ip_src_rx_gs_mult_core;


ARCHITECTURE rtl OF ZynqBF_2t_ip_src_rx_gs_mult_core IS

  -- Signals
  signal macc1_p:               vector_of_signed48(0 to (NDSP-1));
  signal macc1_a:               vector_of_signed16(0 to (NDSP-1));
  signal macc1_b:               vector_of_signed16(0 to (NDSP-1));
  signal macc1_c:               vector_of_signed48(0 to (NDSP-1));
  signal macc1_m:               vector_of_signed32(0 to (NDSP-1));
  signal macc1_sum:             signed(47 downto 0);
  
  signal macc2_p:               vector_of_signed48(0 to (NDSP-1));
  signal macc2_a:               vector_of_signed16(0 to (NDSP-1));
  signal macc2_b:               vector_of_signed16(0 to (NDSP-1));
  signal macc2_c:               vector_of_signed48(0 to (NDSP-1));
  signal macc2_m:               vector_of_signed32(0 to (NDSP-1));
  signal macc2_sum:             signed(47 downto 0);
  
  -- enable delays
  signal men_dreg:              std_logic_vector(2 downto 0);
  signal men_d1:                std_logic;
  signal men_d2:                std_logic;
  signal men_d3:                std_logic;
  
  signal scnt_i:                integer range 0 to 7;
  signal sum_sel:               integer range 0 to 7;
  signal sum_shift:             integer range 0 to 128;
  
  -- sum enable delays
  signal sen_dreg:              std_logic_vector(2 downto 0);
  signal sen_d1:                std_logic;
  signal sen_d2:                std_logic;
  signal sen_d3:                std_logic;
  signal scnt_d1:               std_logic_vector(15 downto 0);
  signal scnt_d2:               std_logic_vector(15 downto 0);
  signal scnt_d3:               std_logic_vector(15 downto 0);
  
  -- output drivers
  signal done_i:                std_logic;
  signal dout1:                 signed(31 downto 0);
  signal dout2:                 signed(31 downto 0);
  
  constant NSUM:                integer range 0 to 255 := NDSP/(SCNT_END+1);
  
BEGIN

  scnt_i <= to_integer(unsigned(scnt_d2));
  sum_sel <= SCNT_END - to_integer(unsigned(scnt_d2));
  
  with sum_sel select sum_shift <=
   128 when 7, 
    64 when 6,
    32 when 5,
    16 when 4,
     8 when 3,
     4 when 2,
     2 when 1,
     1 when 0,
     0 when others;
     
   
  register_inputs : process(clk)
  begin
    if clk'event and clk = '1' then
        if reset = '1' then
            for i in 0 to (NDSP-1) loop
                macc1_a(i) <= (others => '0');
                macc1_b(i) <= (others => '0');
                macc2_a(i) <= (others => '0');
                macc2_b(i) <= (others => '0');
            end loop;
        elsif enb = '1' and mult_en = '1' then
        -- elsif enb = '1' then
            for i in 0 to (NDSP-1) loop
                macc1_a(i) <= signed(rxi(i));
                macc1_b(i) <= signed(gsi(i));
                macc2_a(i) <= signed(rxq(i));
                macc2_b(i) <= signed(gsq(i));
            end loop;
        end if;
    end if;
  end process;
  
  calc_mult : process(clk)
  begin
    if clk'event and clk = '1' then
        if reset = '1' then
            for i in 0 to (NDSP-1) loop
                macc1_m(i) <= (others => '0');
                macc2_m(i) <= (others => '0');
            end loop;
        elsif enb = '1' and men_d1 = '1' then
        -- elsif enb = '1' then
            for i in 0 to (NDSP-1) loop
                macc1_m(i) <= macc1_a(i) * macc1_b(i);
                macc2_m(i) <= macc2_a(i) * macc2_b(i);
            end loop;
        end if;
    end if;
  end process;
  
  -- register_c : process(clk)
  -- begin
    -- if clk'event and clk = '1' then
        -- if reset = '1' then
            -- macc_c <= (others => '0');
        -- elsif enb = '1' and en_d1 = '1' then
            -- macc_c <= macc_p;
        -- end if;
    -- end if;
  -- end process;
  
  macc1_c <= macc1_p;
  macc2_c <= macc2_p;
  
  register_p : process(clk)
  begin
    if clk'event and clk = '1' then
        if reset = '1' then
            for i in 0 to (NDSP-1) loop
                macc1_p(i) <= (others => '0');
                macc2_p(i) <= (others => '0');
            end loop;
        elsif enb = '1' and men_d2 = '1' then
        -- elsif enb = '1' then
            for i in 0 to (NDSP-1) loop
                macc1_p(i) <= resize(macc1_m(i),48) + macc1_c(i);
                macc2_p(i) <= resize(macc2_m(i),48) + macc2_c(i);
            end loop;
        --elsif sen_d2 = '1' then
        --    for i in 0 to (NDSP-1) loop
        --        if i < sum_shift then
        --            macc1_p(i) <= macc1_p(i) + macc1_p(i+sum_shift);
        --            macc2_p(i) <= macc2_p(i) + macc2_p(i+sum_shift);
        --        end if;
        --    end loop;
        elsif men_d2 = '0' and sen_dreg = "000" then
            for i in 0 to (NDSP-1) loop
                macc1_p(i) <= (others => '0');
                macc2_p(i) <= (others => '0');
            end loop;
        end if;
    end if;
  end process;
  
  sum_process : process(clk)
    variable sum_macc1_i : signed(47 downto 0);
    variable sum_macc2_i : signed(47 downto 0);
  begin
    sum_macc1_i := (others => '0');
    sum_macc2_i := (others => '0');
    if clk'event and clk = '1' then
        if reset = '1' then
            macc1_sum <= (others => '0');
            macc2_sum <= (others => '0');
        elsif enb = '1' then
            if men_d2 = '1' then
                macc1_sum <= (others => '0');
                macc2_sum <= (others => '0');
            elsif sen_d2 = '1' then
                for i in 0 to (NSUM-1) loop
                    sum_macc1_i := sum_macc1_i + macc1_p(NSUM*scnt_i + i);
                    sum_macc2_i := sum_macc2_i + macc2_p(NSUM*scnt_i + i);
                end loop;
                macc1_sum <= macc1_sum + sum_macc1_i;
                macc2_sum <= macc2_sum + sum_macc2_i;
            end if;
        end if;
    end if;
  end process;
            
  
  enable_delay_process : process(clk)
  begin
    if clk'event and clk = '1' then
        if reset = '1' then
            men_dreg <= "000";
            sen_dreg <= "000";
        elsif enb = '1' then
            men_dreg <= men_dreg(1 downto 0) & mult_en;
            sen_dreg <= sen_dreg(1 downto 0) & sum_en;
        end if;
    end if;
  end process;
  
  men_d1 <= men_dreg(0);
  men_d2 <= men_dreg(1);
  men_d3 <= men_dreg(2);
  
  sen_d1 <= sen_dreg(0);
  sen_d2 <= sen_dreg(1);
  sen_d3 <= sen_dreg(2);
  
  scnt_delay_process : process(clk)
  begin
    if clk'event and clk = '1' then
        if reset = '1' then
            scnt_d1 <= x"0000";
            scnt_d2 <= x"0000";
            scnt_d3 <= x"0000";
        elsif enb = '1' then
            scnt_d1 <= scnt;
            scnt_d2 <= scnt_d1;
            scnt_d3 <= scnt_d2;
        end if;
    end if;
  end process;
  
  register_outputs : process(clk)
  begin
    if clk'event and clk = '1' then
        if reset = '1' then
            done_i <= '0';
            dout1 <= x"00000000";
            dout2 <= x"00000000";
        elsif enb = '1' and unsigned(scnt_d3) >= to_unsigned(SCNT_END,16) then
            done_i <= '1';
            dout1 <= macc1_sum(45 downto 14);
            dout2 <= macc2_sum(45 downto 14);
        else
            done_i <= '0';
            dout1 <= dout1;
            dout2 <= dout2;
        end if;
    end if;
  end process;
            
  done <= done_i;
  dout <= std_logic_vector(dout1 + dout2);

END rtl;

