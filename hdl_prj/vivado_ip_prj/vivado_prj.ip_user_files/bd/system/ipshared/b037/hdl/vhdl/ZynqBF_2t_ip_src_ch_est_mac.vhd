-- -------------------------------------------------------------
-- 
-- File Name: hdl_prj\hdlsrc\ZynqBF_2tx_fpga\ZynqBF_2t_ip_src_ch_est.vhd
-- Created: 2019-02-08 23:33:52
-- 
-- Generated by MATLAB 9.5 and HDL Coder 3.13
-- 
-- -------------------------------------------------------------


-- -------------------------------------------------------------
-- 
-- Module: ZynqBF_2t_ip_src_ch_est
-- Source Path: ZynqBF_2tx_fpga/channel_estimator/ch_est
-- Hierarchy Level: 2
-- 
-- -------------------------------------------------------------
LIBRARY IEEE;
USE IEEE.std_logic_1164.ALL;
USE IEEE.numeric_std.ALL;
USE work.ZynqBF_2t_ip_src_ZynqBF_2tx_fpga_pkg.ALL;

ENTITY ZynqBF_2t_ip_src_ch_est_mac IS
  PORT( clk                               :   IN    std_logic;
        reset                             :   IN    std_logic;
        enb                               :   IN    std_logic;
        start                             :   IN    std_logic;
        en                                :   IN    std_logic;
        last                              :   IN    std_logic;
        din1                              :   IN    std_logic_vector(15 downto 0);  -- sfix16_En15
        din2                              :   IN    std_logic_vector(15 downto 0);  -- sfix16_En15
        ready                             :   OUT   std_logic;
        dout                              :   OUT   std_logic_vector(31 DOWNTO 0)  -- sfix32_En14
        );
END ZynqBF_2t_ip_src_ch_est_mac;


ARCHITECTURE rtl OF ZynqBF_2t_ip_src_ch_est_mac IS

    signal macc_a, macc_b                   : signed(15 downto 0);
    signal macc_m                           : signed(31 downto 0);
    signal macc_c, macc_p                   : signed(47 downto 0);
    signal macc_p_trunc                     : signed(45 downto 0);
    
    signal en_dreg                          : std_logic_vector(2 downto 0);
    signal en_d1, en_d2, en_d3              : std_logic;
    
    signal last_dreg                        : unsigned(7 downto 0);
    
BEGIN

    en_d1 <= en_dreg(0);
    en_d2 <= en_dreg(1);
    en_d3 <= en_dreg(2);
    ready <= last_dreg(3);
    macc_c <= macc_p;
    macc_p_trunc <= resize(macc_p,46);
    
    en_delay : process(clk)
    begin
        if clk'event and clk = '1' then
            if reset = '1' then
                en_dreg <= (others => '0');
            else
                en_dreg <= en_dreg(en_dreg'high-1 downto 0) & en;
            end if;
        end if;
    end process;
    
    
    last_delay : process(clk)
    begin
        if clk'event and clk = '1' then
            if reset = '1' then
                last_dreg <= (others => '0');
            else
                last_dreg <= last_dreg(last_dreg'high-1 downto 0) & last;
            end if;
        end if;
    end process;
    
    
    register_inputs : process(clk)
    begin
        if clk'event and clk = '1' then
            if reset = '1' then
                macc_a <= (others => '0');
                macc_b <= (others => '0');
            elsif enb = '1' and en = '1' then
                if unsigned(last_dreg) > to_unsigned(16#0#, last_dreg'high+1) then
                    macc_a <= (others => '0');
                    macc_b <= (others => '0');
                else
                    macc_a <= signed(din1);
                    macc_b <= signed(din2);
                end if;
            end if;
        end if;
    end process;
    
    
    calc_mult : process(clk)
    begin
        if clk'event and clk = '1' then
            if reset = '1' or start = '1' then
                macc_m <= (others => '0');
            elsif enb = '1' and en_d1 = '1' then
                macc_m <= macc_a * macc_b;
            end if;
        end if;
    end process;
    
    
    register_p : process(clk)
    begin
        if clk'event and clk = '1' then
            if reset = '1' or start = '1' then
                macc_p <= (others => '0');
            elsif enb = '1' and en_d2 = '1' then
                macc_p <= resize(macc_m, 48) + macc_c;
            end if;
        end if;
    end process;
    
    
    register_dout : process(clk)
    begin
        if clk'event and clk = '1' then
            if reset = '1' then
                dout <= (others => '0');
            elsif enb = '1' and last_dreg(2) = '1' then
                dout <= std_logic_vector(macc_p_trunc(45 downto 14));
            end if;
        end if;
    end process;
    
END rtl;

